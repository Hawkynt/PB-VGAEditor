' .XPM File Format Module


'******************************************************************************
'* SUB: WriteXPMFile
'* Purpose: Writes the canvas to a .XPM file.
'*          Trims transparent pixels from the edges.
'* Parameters:
'*   fullPath (BYVAL STRING): The full path for the new file.
'*   spr (BYREF Sprite): The sprite metadata (for bounding box).
'*   canvas() (BYREF INTEGER): The sprite data array to save.
'******************************************************************************
SUB WriteXPMFile (BYVAL fullPath AS STRING, spr AS Sprite, canvas() AS INTEGER, errorMessage AS STRING)
    DIM fileNum AS INTEGER
    DIM x AS INTEGER
    DIM y AS INTEGER
    DIM spriteWidth AS INTEGER
    DIM spriteHeight AS INTEGER
    DIM colorChars(0 TO 15) AS STRING
    DIM colorMap(0 TO 15) AS STRING
    DIM rowData AS STRING
    errorMessage = ""

    ' Check if there is anything to save
    IF spr.boundingBoxX2 = -1 THEN EXIT SUB

    spriteWidth = spr.boundingBoxX2 - spr.boundingBoxX1 + 1
    spriteHeight = spr.boundingBoxY2 - spr.boundingBoxY1 + 1

    ' --- Define XPM Characters and Colors ---
    colorChars(0) = " ": colorMap(0) = "c #000000"
    colorChars(1) = ".": colorMap(1) = "c #0000AA"
    colorChars(2) = "X": colorMap(2) = "c #00AA00"
    colorChars(3) = "o": colorMap(3) = "c #00AAAA"
    colorChars(4) = "O": colorMap(4) = "c #AA0000"
    colorChars(5) = "+": colorMap(5) = "c #AA00AA"
    colorChars(6) = "@": colorMap(6) = "c #AA5500"
    colorChars(7) = "#": colorMap(7) = "c #AAAAAA"
    colorChars(8) = "$": colorMap(8) = "c #555555"
    colorChars(9) = "%": colorMap(9) = "c #5555FF"
    colorChars(10) = "&": colorMap(10) = "c #55FF55"
    colorChars(11) = "*": colorMap(11) = "c #55FFFF"
    colorChars(12) = "=": colorMap(12) = "c #FF5555"
    colorChars(13) = "-": colorMap(13) = "c #FF55FF"
    colorChars(14) = ";": colorMap(14) = "c #FFFF55"
    colorChars(15) = ":": colorMap(15) = "c #FFFFFF"

    fileNum = FREEFILE
    OPEN fullPath FOR OUTPUT AS #fileNum

    ' --- Write XPM Header ---
    PRINT #fileNum, "! XPM"
    PRINT #fileNum, "static char * hawkynt_xpm[] = {"
    PRINT #fileNum, CHR$(34) + STR$(spriteWidth) + " " + STR$(spriteHeight) + " 16 1" + CHR$(34) + ","

    ' --- Write Color Map ---
    FOR i = 0 TO 15
        PRINT #fileNum, CHR$(34) + colorChars(i) + " " + colorMap(i) + CHR$(34) + ","
    NEXT i

    ' --- Write Pixel Data ---
    FOR y = spr.boundingBoxY1 TO spr.boundingBoxY2
        rowData = ""
        FOR x = spr.boundingBoxX1 TO spr.boundingBoxX2
            rowData = rowData + colorChars(canvas(x, y))
        NEXT x
        IF y = spr.boundingBoxY2 THEN
            PRINT #fileNum, CHR$(34) + rowData + CHR$(34)
        ELSE
            PRINT #fileNum, CHR$(34) + rowData + CHR$(34) + ","
        END IF
    NEXT y

    PRINT #fileNum, "};"
    CLOSE #fileNum
END SUB


' --- helper: return inner quoted text if present; otherwise the trimmed input, without trailing comma
FUNCTION InnerQuotedOrSelf (s AS STRING) AS STRING
    DIM a AS LONG, b AS LONG, t AS STRING

    t = LTRIM$(RTRIM$(s))
    a = INSTR(t, CHR$(34))
    IF a = 0 THEN
        ' no quote: drop trailing comma if any
        IF RIGHT$(t, 1) = "," THEN t = LEFT$(t, LEN(t) - 1)
        FUNCTION = t
        EXIT FUNCTION
    END IF

    b = INSTR(a + 1, t, CHR$(34))
    IF b = 0 THEN
        ' unmatched quote: best-effort, drop leading quote and trailing comma
        t = MID$(t, a + 1)
        IF RIGHT$(t, 1) = "," THEN t = LEFT$(t, LEN(t) - 1)
        FUNCTION = t
        EXIT FUNCTION
    END IF

    ' return exactly the inner text, ignore anything after the closing quote
    FUNCTION = MID$(t, a + 1, b - a - 1)
END FUNCTION

' ========= Safe, non-terminating helpers (unchanged logic) =========

FUNCTION NextField (s AS STRING) AS STRING
    DIM ch AS STRING
    DIM i AS LONG

    DO WHILE LEN(s) > 0
        ch = LEFT$(s, 1)
        IF ch <> " " AND ch <> CHR$(9) THEN EXIT DO
        s = MID$(s, 2)
    LOOP
    IF LEN(s) = 0 THEN EXIT FUNCTION

    FOR i = 1 TO LEN(s)
        ch = MID$(s, i, 1)
        IF ch = " " OR ch = CHR$(9) THEN EXIT FOR
    NEXT

    FUNCTION = LEFT$(s, i - 1)
    s = MID$(s, i)
END FUNCTION

FUNCTION TryParseNumber (maxDigits AS LONG, s AS STRING, result AS LONG) AS LONG
    DIM tok AS STRING
    DIM ch AS STRING
    DIM i AS LONG
    DIM t AS STRING

    tok = NextField(s)
    IF tok = "" THEN EXIT FUNCTION

    IF LEFT$(tok, 1) = "+" THEN tok = MID$(tok, 2)
    IF LEFT$(tok, 1) = "-" THEN EXIT FUNCTION

    t = tok
    IF LEN(t) = 0 OR LEN(t) > maxDigits THEN EXIT FUNCTION

    FOR i = 1 TO LEN(t)
        ch = MID$(t, i, 1)
        IF ch < "0" OR ch > "9" THEN EXIT FUNCTION
    NEXT

    result = VAL(tok)
    FUNCTION = -1
END FUNCTION

FUNCTION ClampLong (v AS LONG, lo AS LONG, hi AS LONG) AS LONG
    IF v < lo THEN v = lo
    IF v > hi THEN v = hi
    FUNCTION = v
END FUNCTION

' ========= Main loader (never STOP/END) =========

SUB ReadXPMFile (BYVAL fullPath AS STRING, spr AS Sprite, canvas() AS INTEGER, errorMessage AS STRING)
    DIM fileNum AS LONG
    DIM lineData AS STRING
    DIM dims AS STRING
    DIM spriteWidth AS LONG
    DIM spriteHeight AS LONG
    DIM numColors AS LONG
    DIM charsPerPixel AS LONG
    DIM colorMap(0 TO 255) AS INTEGER
    DIM x AS LONG, y AS LONG, i AS LONG
    DIM startX AS LONG, startY AS LONG
    DIM charCode AS LONG
    DIM ok AS LONG
    DIM expectPixelsFrom AS LONG

    errorMessage = ""

    fileNum = FREEFILE
    ON ERROR RESUME NEXT
    OPEN fullPath FOR INPUT AS #fileNum
    IF ERR <> 0 THEN
        errorMessage = "Cannot open file: " + fullPath
        ERRCLEAR
        ON ERROR GOTO 0
        EXIT SUB
    END IF
    ON ERROR GOTO 0

    ' --- Read Header ---
    IF EOF(fileNum) THEN GOTO Fail_EOF
    LINE INPUT #fileNum, lineData
    SELECT CASE LEFT$(UCASE$(LTRIM$(RTRIM$(lineData))), 8)
        CASE "/* XPM */", "! XPM", "'! XPM", "' ! XPM"
            ' ok
        CASE ELSE
            errorMessage = "Invalid XPM header."
            CLOSE #fileNum
            EXIT SUB
    END SELECT

    ' Skip the static char* line (name/declaration)
    IF EOF(fileNum) THEN GOTO Fail_EOF
    LINE INPUT #fileNum, lineData

    ' --- Read Dimensions line (quoted) ---
    IF EOF(fileNum) THEN GOTO Fail_EOF
    LINE INPUT #fileNum, lineData
    dims = InnerQuotedOrSelf(lineData)

    ok = TryParseNumber(5, dims, spriteWidth)   : IF ok = 0 THEN GOTO Fail_ParseDims
    ok = TryParseNumber(5, dims, spriteHeight)  : IF ok = 0 THEN GOTO Fail_ParseDims
    ok = TryParseNumber(5, dims, numColors)     : IF ok = 0 THEN GOTO Fail_ParseDims
    ok = TryParseNumber(5, dims, charsPerPixel) : IF ok = 0 THEN GOTO Fail_ParseDims

    IF charsPerPixel <> 1 THEN
        errorMessage = "Unsupported XPM format: charsPerPixel=" + FORMAT$(charsPerPixel)
        CLOSE #fileNum
        EXIT SUB
    END IF
    IF numColors < 1 OR numColors > 256 THEN
        errorMessage = "Unsupported color count: " + FORMAT$(numColors)
        CLOSE #fileNum
        EXIT SUB
    END IF
    IF spriteWidth < 1 OR spriteHeight < 1 THEN
        errorMessage = "Invalid dimensions: " + FORMAT$(spriteWidth) + "x" + FORMAT$(spriteHeight)
        CLOSE #fileNum
        EXIT SUB
    END IF

    ' --- Read Color Map (quoted lines) ---
    FOR i = 0 TO numColors - 1
        IF EOF(fileNum) THEN GOTO Fail_EOF
        LINE INPUT #fileNum, lineData

        ' Grab the glyph from inside the quotes, position 1 (since charsPerPixel=1)
        DIM colorLine AS STRING
        colorLine = InnerQuotedOrSelf(lineData)
        IF LEN(colorLine) >= 1 THEN
            charCode = ASC(MID$(colorLine, 1, 1))
            IF charCode >= LBOUND(colorMap) AND charCode <= UBOUND(colorMap) THEN
                colorMap(charCode) = CINT(i AND &HFFFF&)
            END IF
        END IF
        ' If malformed, leave default 0 mapping.
    NEXT i

    startX = 0
    startY = 0

    DIM dstMinX AS LONG, dstMinY AS LONG, dstMaxX AS LONG, dstMaxY AS LONG
    dstMinX = ClampLong(startX, 0, spr.spriteWidth - 1)
    dstMinY = ClampLong(startY, 0, spr.spriteHeight - 1)
    dstMaxX = ClampLong(startX + spriteWidth - 1, 0, spr.spriteWidth - 1)
    dstMaxY = ClampLong(startY + spriteHeight - 1, 0, spr.spriteHeight - 1)

    DIM srcOffsetX AS LONG, srcOffsetY AS LONG
    srcOffsetX = dstMinX - startX
    srcOffsetY = dstMinY - startY

    ' --- Read Pixel Data (quoted rows) ---
    expectPixelsFrom = 1  ' because we extracted inner quoted text; first pixel is at index 1

    FOR y = 0 TO spriteHeight - 1
        IF EOF(fileNum) THEN GOTO Fail_EOF
        LINE INPUT #fileNum, lineData

        DIM row AS STRING
        row = InnerQuotedOrSelf(lineData)

        DIM dy AS LONG
        dy = y + startY
        IF dy < 0 OR dy > spr.spriteHeight - 1 THEN ITERATE FOR

        FOR x = 0 TO spriteWidth - 1
            DIM dx AS LONG
            dx = x + startX
            IF dx < dstMinX OR dx > dstMaxX THEN ITERATE FOR

            DIM srcPos AS LONG
            srcPos = expectPixelsFrom + x
            IF srcPos <= LEN(row) THEN
                DIM glyph AS STRING
                glyph = MID$(row, srcPos, 1)
                charCode = ASC(glyph)
                IF charCode >= LBOUND(colorMap) AND charCode <= UBOUND(colorMap) THEN
                    canvas(dx, dy) = colorMap(charCode)
                END IF
            END IF
        NEXT x
    NEXT y

    CLOSE #fileNum
    EXIT SUB

Fail_EOF:
    errorMessage = "Unexpected end of file while reading XPM."
    CLOSE #fileNum
    EXIT SUB

Fail_ParseDims:
    errorMessage = "Malformed dimensions line in XPM."
    CLOSE #fileNum
    EXIT SUB
END SUB
