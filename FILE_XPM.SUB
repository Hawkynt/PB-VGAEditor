' XPM File Format Module
' Common Interface: FileXpm_Read, FileXpm_Write
' Namespace: FileXpm (pseudo-namespace via function prefixes)


'******************************************************************************
'* SUB: FileXpm_Write
'* Purpose: Writes the canvas to a .XPM file.
'*          Trims transparent pixels from the edges.
'* Parameters:
'*   fullPath (BYVAL STRING): The full path for the new file.
'*   spr (BYREF Sprite): The sprite metadata (for bounding box).
'*   canvas() (BYREF INTEGER): The sprite data array to save.
'******************************************************************************
SUB FileXpm_Write (fullPath AS STRING, errorMessage AS STRING)
    DIM fileNum AS INTEGER
    DIM x AS INTEGER
    DIM y AS INTEGER
    DIM spriteWidth AS INTEGER
    DIM spriteHeight AS INTEGER
    DIM colorChars(0 TO 15) AS STRING
    DIM colorMap(0 TO 15) AS STRING
    DIM rowData AS STRING
    errorMessage = ""

    ' Check if there is anything to save
    IF currentSprite.boundingBoxX2 = -1 THEN EXIT SUB

    spriteWidth = currentSprite.boundingBoxX2 - currentSprite.boundingBoxX1 + 1
    spriteHeight = currentSprite.boundingBoxY2 - currentSprite.boundingBoxY1 + 1

    ' --- Define XPM Characters and Colors ---
    colorChars(0) = " ": colorMap(0) = "c #000000"
    colorChars(1) = ".": colorMap(1) = "c #0000AA"
    colorChars(2) = "X": colorMap(2) = "c #00AA00"
    colorChars(3) = "o": colorMap(3) = "c #00AAAA"
    colorChars(4) = "O": colorMap(4) = "c #AA0000"
    colorChars(5) = "+": colorMap(5) = "c #AA00AA"
    colorChars(6) = "@": colorMap(6) = "c #AA5500"
    colorChars(7) = "#": colorMap(7) = "c #AAAAAA"
    colorChars(8) = "$": colorMap(8) = "c #555555"
    colorChars(9) = "%": colorMap(9) = "c #5555FF"
    colorChars(10) = "&": colorMap(10) = "c #55FF55"
    colorChars(11) = "*": colorMap(11) = "c #55FFFF"
    colorChars(12) = "=": colorMap(12) = "c #FF5555"
    colorChars(13) = "-": colorMap(13) = "c #FF55FF"
    colorChars(14) = ";": colorMap(14) = "c #FFFF55"
    colorChars(15) = ":": colorMap(15) = "c #FFFFFF"

    fileNum = FREEFILE
    OPEN fullPath FOR OUTPUT AS #fileNum

    ' --- Write XPM Header ---
    PRINT #fileNum, "! XPM"
    PRINT #fileNum, "static char * hawkynt_xpm[] = {"
    PRINT #fileNum, CHR$(34) + STR$(spriteWidth) + " " + STR$(spriteHeight) + " 16 1" + CHR$(34) + ","

    ' --- Write Color Map ---
    DIM i AS INTEGER
    FOR i = 0 TO 15
        PRINT #fileNum, CHR$(34) + colorChars(i) + " " + colorMap(i) + CHR$(34) + ","
    NEXT i

    ' --- Write Pixel Data ---
    FOR y = currentSprite.boundingBoxY1 TO currentSprite.boundingBoxY2
        rowData = ""
        FOR x = currentSprite.boundingBoxX1 TO currentSprite.boundingBoxX2
            rowData = rowData + colorChars(currentCanvas(x, y))
        NEXT x
        IF y = currentSprite.boundingBoxY2 THEN
            PRINT #fileNum, CHR$(34) + rowData + CHR$(34)
        ELSE
            PRINT #fileNum, CHR$(34) + rowData + CHR$(34) + ","
        END IF
    NEXT y

    PRINT #fileNum, "};"
    CLOSE #fileNum
END SUB


' --- helper: return inner quoted text if present; otherwise the trimmed input, without trailing comma
FUNCTION InnerQuotedOrSelf (s AS STRING) AS STRING
    DIM a AS LONG, b AS LONG, t AS STRING

    t = LTRIM$(RTRIM$(s))
    a = INSTR(t, CHR$(34))
    IF a = 0 THEN
        ' no quote: drop trailing comma if any
        IF RIGHT$(t, 1) = "," THEN t = LEFT$(t, LEN(t) - 1)
        FUNCTION = t
        EXIT FUNCTION
    END IF

    b = INSTR(a + 1, t, CHR$(34))
    IF b = 0 THEN
        ' unmatched quote: best-effort, drop leading quote and trailing comma
        t = MID$(t, a + 1)
        IF RIGHT$(t, 1) = "," THEN t = LEFT$(t, LEN(t) - 1)
        FUNCTION = t
        EXIT FUNCTION
    END IF

    ' return exactly the inner text, ignore anything after the closing quote
    FUNCTION = MID$(t, a + 1, b - a - 1)
END FUNCTION

' ========= Safe, non-terminating helpers (unchanged logic) =========

FUNCTION NextField (s AS STRING) AS STRING
    DIM ch AS STRING
    DIM i AS LONG

    DO WHILE LEN(s) > 0
        ch = LEFT$(s, 1)
        IF ch <> " " AND ch <> CHR$(9) THEN EXIT DO
        s = MID$(s, 2)
    LOOP
    IF LEN(s) = 0 THEN EXIT FUNCTION

    FOR i = 1 TO LEN(s)
        ch = MID$(s, i, 1)
        IF ch = " " OR ch = CHR$(9) THEN EXIT FOR
    NEXT

    FUNCTION = LEFT$(s, i - 1)
    s = MID$(s, i)
END FUNCTION

FUNCTION TryParseNumber (maxDigits AS LONG, s AS STRING, result AS LONG) AS LONG
    DIM tok AS STRING
    DIM ch AS STRING
    DIM i AS LONG
    DIM t AS STRING

    tok = NextField(s)
    IF tok = "" THEN EXIT FUNCTION

    IF LEFT$(tok, 1) = "+" THEN tok = MID$(tok, 2)
    IF LEFT$(tok, 1) = "-" THEN EXIT FUNCTION

    t = tok
    IF LEN(t) = 0 OR LEN(t) > maxDigits THEN EXIT FUNCTION

    FOR i = 1 TO LEN(t)
        ch = MID$(t, i, 1)
        IF ch < "0" OR ch > "9" THEN EXIT FUNCTION
    NEXT

    result = VAL(tok)
    FUNCTION = -1
END FUNCTION

FUNCTION ClampLong (v AS LONG, lo AS LONG, hi AS LONG) AS LONG
    IF v < lo THEN v = lo
    IF v > hi THEN v = hi
    FUNCTION = v
END FUNCTION

' ========= Main loader (never STOP/END) =========

SUB FileXpm_Read (fullPath AS STRING, errorMessage AS STRING)
    DIM fileNum AS LONG
    DIM lineData AS STRING
    DIM dims AS STRING
    DIM spriteWidth AS LONG
    DIM spriteHeight AS LONG
    DIM numColors AS LONG
    DIM charsPerPixel AS LONG
    DIM colorMap(0 TO 255) AS INTEGER
    DIM x AS LONG, y AS LONG, i AS LONG
    DIM startX AS LONG, startY AS LONG
    DIM charCode AS LONG
    DIM ok AS LONG
    DIM expectPixelsFrom AS LONG

    errorMessage = ""

    fileNum = FREEFILE
    ON ERROR RESUME NEXT
    OPEN fullPath FOR INPUT AS #fileNum
    IF ERR <> 0 THEN
        errorMessage = "Cannot open file: " + fullPath
        ERRCLEAR
        ON ERROR GOTO 0
        EXIT SUB
    END IF
    ON ERROR GOTO 0

    ' --- Read Header ---
    IF EOF(fileNum) THEN GOTO Fail_EOF
    LINE INPUT #fileNum, lineData
    SELECT CASE LEFT$(UCASE$(LTRIM$(RTRIM$(lineData))), 8)
        CASE "/* XPM */", "! XPM", "'! XPM", "' ! XPM"
            ' ok
        CASE ELSE
            errorMessage = "Invalid XPM header."
            CLOSE #fileNum
            EXIT SUB
    END SELECT

    ' Skip the static char* line (name/declaration)
    IF EOF(fileNum) THEN GOTO Fail_EOF
    LINE INPUT #fileNum, lineData

    ' --- Read Dimensions line (quoted) ---
    IF EOF(fileNum) THEN GOTO Fail_EOF
    LINE INPUT #fileNum, lineData
    dims = InnerQuotedOrSelf(lineData)

    ok = TryParseNumber(5, dims, spriteWidth)   : IF ok = 0 THEN GOTO Fail_ParseDims
    ok = TryParseNumber(5, dims, spriteHeight)  : IF ok = 0 THEN GOTO Fail_ParseDims
    ok = TryParseNumber(5, dims, numColors)     : IF ok = 0 THEN GOTO Fail_ParseDims
    ok = TryParseNumber(5, dims, charsPerPixel) : IF ok = 0 THEN GOTO Fail_ParseDims

    IF charsPerPixel <> 1 THEN
        errorMessage = "Unsupported XPM format: charsPerPixel=" + STR$(charsPerPixel)
        CLOSE #fileNum
        EXIT SUB
    END IF
    IF numColors < 1 OR numColors > 256 THEN
        errorMessage = "Unsupported color count: " + STR$(numColors)
        CLOSE #fileNum
        EXIT SUB
    END IF
    IF spriteWidth < 1 OR spriteHeight < 1 THEN
        errorMessage = "Invalid dimensions: " + STR$(spriteWidth) + "x" + STR$(spriteHeight)
        CLOSE #fileNum
        EXIT SUB
    END IF

    ' --- Read Color Map (quoted lines) ---
    FOR i = 0 TO numColors - 1
        IF EOF(fileNum) THEN GOTO Fail_EOF
        LINE INPUT #fileNum, lineData

        ' Grab the glyph from inside the quotes, position 1 (since charsPerPixel=1)
        DIM colorLine AS STRING
        colorLine = InnerQuotedOrSelf(lineData)
        IF LEN(colorLine) >= 1 THEN
            charCode = ASC(MID$(colorLine, 1, 1))
            IF charCode >= LBOUND(colorMap) AND charCode <= UBOUND(colorMap) THEN
                ' Map character to actual VGA color index based on color chars in writer
                DIM vgaColorIndex AS INTEGER
                SELECT CASE charCode
                    CASE 32: vgaColorIndex = 0   ' space → black
                    CASE 46: vgaColorIndex = 1   ' . → blue  
                    CASE 88: vgaColorIndex = 2   ' X → green
                    CASE 111: vgaColorIndex = 3  ' o → cyan
                    CASE 79: vgaColorIndex = 4   ' O → red
                    CASE 43: vgaColorIndex = 5   ' + → magenta
                    CASE 64: vgaColorIndex = 6   ' @ → brown
                    CASE 35: vgaColorIndex = 7   ' # → light gray
                    CASE 36: vgaColorIndex = 8   ' $ → dark gray
                    CASE 37: vgaColorIndex = 9   ' % → light blue
                    CASE 38: vgaColorIndex = 10  ' & → light green
                    CASE 42: vgaColorIndex = 11  ' * → light cyan
                    CASE 61: vgaColorIndex = 12  ' = → light red
                    CASE 45: vgaColorIndex = 13  ' - → light magenta
                    CASE 59: vgaColorIndex = 14  ' ; → yellow
                    CASE 58: vgaColorIndex = 15  ' : → white
                    CASE ELSE: vgaColorIndex = 0
                END SELECT
                colorMap(charCode) = vgaColorIndex
            END IF
        END IF
    NEXT i

    startX = 0
    startY = 0

    ' Ensure sprite dimensions are adequate for the image size
    IF spriteWidth > currentSprite.spriteWidth THEN currentSprite.spriteWidth = spriteWidth
    IF spriteHeight > currentSprite.spriteHeight THEN currentSprite.spriteHeight = spriteHeight

    DIM dstMinX AS LONG, dstMinY AS LONG, dstMaxX AS LONG, dstMaxY AS LONG
    dstMinX = ClampLong(startX, 0, currentSprite.spriteWidth - 1)
    dstMinY = ClampLong(startY, 0, currentSprite.spriteHeight - 1)
    dstMaxX = ClampLong(startX + spriteWidth - 1, 0, currentSprite.spriteWidth - 1)
    dstMaxY = ClampLong(startY + spriteHeight - 1, 0, currentSprite.spriteHeight - 1)

    DIM srcOffsetX AS LONG, srcOffsetY AS LONG
    srcOffsetX = dstMinX - startX
    srcOffsetY = dstMinY - startY

    ' --- Read Pixel Data (quoted rows) ---
    expectPixelsFrom = 1  ' because we extracted inner quoted text; first pixel is at index 1

    FOR y = 0 TO spriteHeight - 1
        IF EOF(fileNum) THEN GOTO Fail_EOF
        LINE INPUT #fileNum, lineData

        DIM row AS STRING
        row = InnerQuotedOrSelf(lineData)

        DIM dy AS LONG
        dy = y + startY
        IF dy < 0 OR dy > currentSprite.spriteHeight - 1 THEN ITERATE FOR

        FOR x = 0 TO spriteWidth - 1
            DIM dx AS LONG
            dx = x + startX
            IF dx < dstMinX OR dx > dstMaxX THEN ITERATE FOR

            DIM srcPos AS LONG
            srcPos = expectPixelsFrom + x
            IF srcPos <= LEN(row) THEN
                DIM glyph AS STRING
                glyph = MID$(row, srcPos, 1)
                charCode = ASC(glyph)
                IF charCode >= LBOUND(colorMap) AND charCode <= UBOUND(colorMap) THEN
                    currentCanvas(dx, dy) = colorMap(charCode)
                END IF
            END IF
        NEXT x
    NEXT y

    CLOSE #fileNum
    
    ' Update bounding box to match loaded data dimensions at (0,0)
    currentSprite.boundingBoxX1 = 0
    currentSprite.boundingBoxY1 = 0
    currentSprite.boundingBoxX2 = spriteWidth - 1
    currentSprite.boundingBoxY2 = spriteHeight - 1
    EXIT SUB

Fail_EOF:
    errorMessage = "Unexpected end of file while reading XPM."
    CLOSE #fileNum
    EXIT SUB

Fail_ParseDims:
    errorMessage = "Malformed dimensions line in XPM."
    CLOSE #fileNum
    EXIT SUB
END SUB
