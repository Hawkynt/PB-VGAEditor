' PCX File Format Module
' Common Interface: FilePcx_Read, FilePcx_Write
' Namespace: FilePcx (pseudo-namespace via function prefixes)


TYPE PCXHeader
    Manufacturer AS BYTE
    Version      AS BYTE
    Encoding     AS BYTE
    BitsPerPixel AS BYTE
    Xmin         AS INTEGER
    Ymin         AS INTEGER
    Xmax         AS INTEGER
    Ymax         AS INTEGER
    HDpi         AS INTEGER
    VDpi         AS INTEGER
    Colormap     AS STRING * 48
    Reserved     AS BYTE
    NPlanes      AS BYTE
    BytesPerLine AS INTEGER
    PaletteInfo  AS INTEGER
    HScrSize     AS INTEGER
    VScrSize     AS INTEGER
    Filler       AS STRING * 54
END TYPE

'******************************************************************************
'* SUB: FilePcx_Write
'* Purpose: Writes the canvas to a .PCX file using RLE compression.
'*          Trims transparent pixels from the edges.
'* Parameters:
'*   fullPath (BYVAL STRING): The full path for the new file.
'*   spr (BYREF Sprite): The sprite metadata (for bounding box).
'*   canvas() (BYREF INTEGER): The sprite data array to save.
'******************************************************************************
SUB FilePcx_Write (fullPath AS STRING, errorMessage AS STRING)
    DIM header AS PCXHeader
    DIM fileNum AS INTEGER
    DIM x AS INTEGER
    DIM y AS INTEGER
    DIM spriteWidth AS INTEGER
    DIM spriteHeight AS INTEGER
    DIM runCount AS INTEGER
    DIM runValue AS INTEGER
    DIM vgaPalette(0 TO 15) AS STRING * 3
    DIM byteVal AS STRING * 1
    DIM paddingBytes AS STRING
    errorMessage = ""

    ' Check if there is anything to save
    IF currentSprite.boundingBoxX2 = -1 THEN EXIT SUB

    spriteWidth = currentSprite.boundingBoxX2 - currentSprite.boundingBoxX1 + 1
    spriteHeight = currentSprite.boundingBoxY2 - currentSprite.boundingBoxY1 + 1

    ' --- Fill PCX Header ---
    header.Manufacturer = 10 ' ZSoft
    header.Version = 5      ' Version 3.0 with palette
    header.Encoding = 1      ' RLE encoding
    header.BitsPerPixel = 8  ' 8 bits per pixel
    header.Xmin = 0
    header.Ymin = 0
    header.Xmax = spriteWidth - 1
    header.Ymax = spriteHeight - 1
    header.HDpi = spriteWidth
    header.VDpi = spriteHeight
    header.Colormap = STRING$(48, 0) ' Not used for VGA
    header.Reserved = 0
    header.NPlanes = 1 ' 1 plane for 256-color mode
    header.BytesPerLine = spriteWidth
    header.PaletteInfo = 1 ' Color
    header.HScrSize = currentSprite.boundingBoxX1  ' Store original X offset
    header.VScrSize = currentSprite.boundingBoxY1  ' Store original Y offset
    header.Filler = STRING$(54, 0)

    fileNum = FREEFILE
    OPEN fullPath FOR BINARY AS #fileNum

    ' --- Write Header ---
    PUT #fileNum, , header

    ' --- Write Image Data with RLE ---
    FOR y = currentSprite.boundingBoxY1 TO currentSprite.boundingBoxY2
        x = currentSprite.boundingBoxX1
        DO WHILE x <= currentSprite.boundingBoxX2
            runValue = currentCanvas(x, y)
            runCount = 1
            x = x + 1
            DO WHILE x <= currentSprite.boundingBoxX2 AND currentCanvas(x, y) = runValue AND runCount < 63
                runCount = runCount + 1
                x = x + 1
            LOOP
            
            IF runCount > 1 OR (runValue AND &HC0) = &HC0 THEN
                byteVal = CHR$(&HC0 OR runCount)
                PUT #fileNum, , byteVal
            END IF
            byteVal = CHR$(runValue)
            PUT #fileNum, , byteVal
        LOOP
    NEXT y

    ' --- Write 256-Color Palette Signature and Palette ---
    byteVal = CHR$(12) ' Palette signature
    PUT #fileNum, , byteVal

    vgaPalette(0) = CHR$(0, 0, 0): vgaPalette(1) = CHR$(0, 0, 170): vgaPalette(2) = CHR$(0, 170, 0): vgaPalette(3) = CHR$(0, 170, 170)
    vgaPalette(4) = CHR$(170, 0, 0): vgaPalette(5) = CHR$(170, 0, 170): vgaPalette(6) = CHR$(170, 85, 0): vgaPalette(7) = CHR$(170, 170, 170)
    vgaPalette(8) = CHR$(85, 85, 85): vgaPalette(9) = CHR$(85, 85, 255): vgaPalette(10) = CHR$(85, 255, 85): vgaPalette(11) = CHR$(85, 255, 255)
    vgaPalette(12) = CHR$(255, 85, 85): vgaPalette(13) = CHR$(255, 85, 255): vgaPalette(14) = CHR$(255, 255, 85): vgaPalette(15) = CHR$(255, 255, 255)
    
    FOR x = 0 TO 15
        PUT #fileNum, , vgaPalette(x)
    NEXT x
    
    ' Pad the rest of the 256-color palette
    paddingBytes = STRING$(240 * 3, 0)
    PUT #fileNum, , paddingBytes

    CLOSE #fileNum
END SUB

'******************************************************************************
'* SUB: FilePcx_Read
'* Purpose: Reads a .PCX file into the canvas.
'* Parameters:
'*   fullPath (BYVAL STRING): The full path to the .PCX file.
'*   spr (BYREF Sprite): The sprite metadata.
'*   canvas() (BYREF INTEGER): The sprite data array to fill.
'******************************************************************************
SUB FilePcx_Read (fullPath AS STRING, errorMessage AS STRING)
    DIM header AS PCXHeader
    DIM fileNum AS INTEGER
    DIM x AS INTEGER
    DIM y AS INTEGER
    DIM spriteWidth AS INTEGER
    DIM spriteHeight AS INTEGER
    DIM startX AS INTEGER
    DIM startY AS INTEGER
    DIM runCount AS INTEGER
    DIM runValue AS INTEGER
    DIM dataByte AS STRING * 1
    DIM i AS INTEGER
    errorMessage = ""

    fileNum = FREEFILE
    OPEN fullPath FOR BINARY AS #fileNum

    ' --- Read Header ---
    GET #fileNum, , header

    ' --- Validate Header ---
    IF header.Manufacturer <> 10 OR header.Encoding <> 1 OR header.BitsPerPixel <> 8 THEN
        errorMessage = "Not a valid 256-color PCX file."
        CLOSE #fileNum
        EXIT SUB
    END IF

    spriteWidth = header.Xmax - header.Xmin + 1
    spriteHeight = header.Ymax - header.Ymin + 1

    ' Update sprite bounding box to match PCX dimensions at 0,0 position
    currentSprite.boundingBoxX1 = 0
    currentSprite.boundingBoxY1 = 0
    currentSprite.boundingBoxX2 = spriteWidth - 1
    currentSprite.boundingBoxY2 = spriteHeight - 1

    ' --- Read Image Data with RLE Decompression ---
    FOR y = 0 TO spriteHeight - 1
        x = 0
        DO WHILE x < spriteWidth
            GET #fileNum, , dataByte
            IF (ASC(dataByte) AND &HC0) = &HC0 THEN
                runCount = ASC(dataByte) AND &H3F
                GET #fileNum, , dataByte
                runValue = ASC(dataByte)
            ELSE
                runCount = 1
                runValue = ASC(dataByte)
            END IF

            FOR i = 1 TO runCount
                IF (startX + x + i - 1) <= currentSprite.spriteWidth AND (startY + y) <= currentSprite.spriteHeight THEN
                    currentCanvas(startX + x + i - 1, startY + y) = runValue
                END IF
            NEXT i
            x = x + runCount
        LOOP
    NEXT y

    CLOSE #fileNum
END SUB
