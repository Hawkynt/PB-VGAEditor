' BMP File Format Module
' Common Interface: FileBmp_Read, FileBmp_Write
' Namespace: FileBmp (pseudo-namespace via function prefixes)


TYPE BMPHeader
    bfType      AS STRING * 2
    bfSize      AS LONG
    bfReserved1 AS INTEGER
    bfReserved2 AS INTEGER
    bfOffBits   AS LONG
END TYPE

TYPE BMPInfoHeader
    biSize          AS LONG
    biWidth         AS LONG
    biHeight        AS LONG
    biPlanes        AS INTEGER
    biBitCount      AS INTEGER
    biCompression   AS LONG
    biSizeImage     AS LONG
    biXPelsPerMeter AS LONG
    biYPelsPerMeter AS LONG
    biClrUsed       AS LONG
    biClrImportant  AS LONG
END TYPE

'******************************************************************************
'* SUB: FileBmp_Write
'* Purpose: Writes the canvas to a 16-color .BMP file.
'*          Trims transparent pixels from the edges.
'* Parameters:
'*   fullPath (BYVAL STRING): The full path for the new file.
'*   spr (BYREF Sprite): The sprite metadata (for bounding box).
'*   canvas() (BYREF INTEGER): The sprite data array to save.
'******************************************************************************
SUB FileBmp_Write (fullPath AS STRING, spr AS Sprite, canvas() AS INTEGER, errorMessage AS STRING)
    DIM bmpH AS BMPHeader
    DIM bmpIH AS BMPInfoHeader
    DIM fileNum AS INTEGER
    DIM x AS INTEGER
    DIM y AS INTEGER
    DIM spriteWidth AS INTEGER
    DIM spriteHeight AS INTEGER
    DIM rowPadding AS INTEGER
    DIM rowSize AS INTEGER
    DIM pixelDataSize AS LONG
    DIM vgaPalette(0 TO 15) AS LONG
    DIM byteVal AS STRING * 1
    DIM p1 AS INTEGER
    DIM p2 AS INTEGER
    DIM paddingBytes AS STRING
    errorMessage = ""

    ' Check if there is anything to save
    IF spr.boundingBoxX2 = -1 THEN EXIT SUB

    spriteWidth = spr.boundingBoxX2 - spr.boundingBoxX1 + 1
    spriteHeight = spr.boundingBoxY2 - spr.boundingBoxY1 + 1

    ' BMP rows are padded to a multiple of 4 bytes
    rowSize = INT((spriteWidth * 4 + 31) / 32) * 4
    rowPadding = rowSize - (spriteWidth / 2)
    pixelDataSize = rowSize * spriteHeight

    ' --- Fill BMP File Header ---
    bmpH.bfType = "BM"
    bmpH.bfSize = 54 + (16 * 4) + pixelDataSize
    bmpH.bfReserved1 = 0
    bmpH.bfReserved2 = 0
    bmpH.bfOffBits = 54 + (16 * 4)

    ' --- Fill BMP Info Header ---
    bmpIH.biSize = 40
    bmpIH.biWidth = spriteWidth
    bmpIH.biHeight = spriteHeight
    bmpIH.biPlanes = 1
    bmpIH.biBitCount = 4 ' 4 bits per pixel for 16 colors
    bmpIH.biCompression = 0 ' BI_RGB (no compression)
    bmpIH.biSizeImage = pixelDataSize
    bmpIH.biXPelsPerMeter = 0
    bmpIH.biYPelsPerMeter = 0
    bmpIH.biClrUsed = 16
    bmpIH.biClrImportant = 16

    fileNum = FREEFILE
    OPEN fullPath FOR BINARY AS #fileNum

    ' --- Write Headers ---
    PUT #fileNum, , bmpH
    PUT #fileNum, , bmpIH

    ' --- Write Palette (BGR format) ---
    vgaPalette(0) = &H000000: vgaPalette(1) = &HAA0000: vgaPalette(2) = &H00AA00: vgaPalette(3) = &HAAAA00
    vgaPalette(4) = &H0000AA: vgaPalette(5) = &HAA00AA: vgaPalette(6) = &H0055AA: vgaPalette(7) = &HAAAAAA
    vgaPalette(8) = &H555555: vgaPalette(9) = &HFF5555: vgaPalette(10) = &H55FF55: vgaPalette(11) = &HFFFF55
    vgaPalette(12) = &H5555FF: vgaPalette(13) = &HFF55FF: vgaPalette(14) = &H55FFFF: vgaPalette(15) = &HFFFFFF
    FOR x = 0 TO 15
        PUT #fileNum, , vgaPalette(x)
    NEXT x

    ' --- Write Pixel Data (upside-down and packed) ---
    FOR y = spr.boundingBoxY2 TO spr.boundingBoxY1 STEP -1
        FOR x = spr.boundingBoxX1 TO spr.boundingBoxX2 STEP 2
            p1 = canvas(x, y)
            IF x + 1 > spr.boundingBoxX2 THEN
                p2 = 0
            ELSE
                p2 = canvas(x + 1, y)
            END IF
            byteVal = CHR$((p1 * 16) + p2)
            PUT #fileNum, , byteVal
        NEXT x
        IF rowPadding > 0 THEN
            paddingBytes = STRING$(rowPadding, 0)
            PUT #fileNum, , paddingBytes
        END IF
    NEXT y

    CLOSE #fileNum
END SUB

'******************************************************************************
'* SUB: FileBmp_Read
'* Purpose: Reads a 16-color .BMP file into the canvas.
'* Parameters:
'*   fullPath (BYVAL STRING): The full path to the .BMP file.
'*   spr (BYREF Sprite): The sprite metadata.
'*   canvas() (BYREF INTEGER): The sprite data array to fill.
'******************************************************************************
SUB FileBmp_Read (fullPath AS STRING, spr AS Sprite, canvas() AS INTEGER, errorMessage AS STRING)
    DIM bmpH AS BMPHeader
    DIM bmpIH AS BMPInfoHeader
    DIM fileNum AS INTEGER
    DIM x AS LONG, y AS LONG
    DIM spriteWidth AS LONG, spriteHeight AS LONG
    DIM topDown AS LONG
    DIM startX AS LONG, startY AS LONG
    DIM rowBytes AS LONG, rowSize AS LONG, rowPadding AS LONG
    DIM b AS LONG
    DIM byteVal AS STRING * 1
    DIM p1 AS INTEGER, p2 AS INTEGER
    DIM dx AS LONG, dy AS LONG
    DIM srcX AS LONG, srcY AS LONG
    DIM y0 AS LONG, yStep AS LONG
    DIM curPos AS LONG

    errorMessage = ""

    fileNum = FREEFILE
    ON ERROR RESUME NEXT
    OPEN fullPath FOR BINARY AS #fileNum
    IF ERR <> 0 THEN
        errorMessage = "Cannot open file: " + fullPath
        ERRCLEAR : ON ERROR GOTO 0
        EXIT SUB
    END IF
    ON ERROR GOTO 0

    ' --- Headers ---
    GET #fileNum, , bmpH
    GET #fileNum, , bmpIH

    ' --- Validate ---
    IF bmpH.bfType <> "BM" THEN
        errorMessage = "Not a BMP."
        CLOSE #fileNum : EXIT SUB
    END IF
    IF bmpIH.biBitCount <> 4 THEN
        errorMessage = "Only 4bpp (16-color) BMP supported."
        CLOSE #fileNum : EXIT SUB
    END IF
    IF bmpIH.biCompression <> 0 THEN
        errorMessage = "Compressed BMP not supported."
        CLOSE #fileNum : EXIT SUB
    END IF

    spriteWidth  = bmpIH.biWidth
    spriteHeight = bmpIH.biHeight
    topDown = 0
    IF spriteHeight < 0 THEN
        topDown = 1
        spriteHeight = -spriteHeight
    END IF
    IF spriteWidth <= 0 OR spriteHeight <= 0 THEN
        errorMessage = "Invalid BMP dimensions."
        CLOSE #fileNum : EXIT SUB
    END IF

    ' 4bpp -> 2 pixels/byte
    rowBytes   = (spriteWidth + 1) \ 2
    rowSize    = ((rowBytes + 3) \ 4) * 4
    rowPadding = rowSize - rowBytes

    startX = 0
    startY = 0

    ' Seek to pixel data (PB SEEK setter has no '#'; offset is 1-based position)
    SEEK fileNum, bmpH.bfOffBits + 1

    ' Row order
    IF topDown THEN
        y0 = 0 : yStep = 1
    ELSE
        y0 = spriteHeight - 1 : yStep = -1
    END IF

    ' --- Pixels ---
    FOR y = 0 TO spriteHeight - 1
        srcY = y0 + y * yStep
        dy = startY + srcY
        ' consume row anyway; only draw if dy in bounds
        FOR b = 0 TO rowBytes - 1
            ON ERROR RESUME NEXT
            GET #fileNum, , byteVal
            IF ERR <> 0 OR LEN(byteVal) <> 1 THEN
                errorMessage = "Unexpected EOF in BMP pixel data."
                ERRCLEAR : ON ERROR GOTO 0
                CLOSE #fileNum : EXIT SUB
            END IF
            ON ERROR GOTO 0

            p1 = ASC(byteVal) \ 16
            p2 = ASC(byteVal) AND 15

            IF dy >= 0 AND dy < spr.spriteHeight THEN
                ' left pixel at x = b*2
                srcX = b * 2
                dx = startX + srcX
                IF dx >= 0 AND dx < spr.spriteWidth THEN
                    canvas(dx, dy) = p1
                END IF

                ' right pixel at x = b*2+1, only if within width
                srcX = b * 2 + 1
                IF srcX < spriteWidth THEN
                    dx = startX + srcX
                    IF dx >= 0 AND dx < spr.spriteWidth THEN
                        canvas(dx, dy) = p2
                    END IF
                END IF
            END IF
        NEXT b

        ' skip row padding
        IF rowPadding > 0 THEN
            curPos = SEEK(fileNum) + rowPadding
            SEEK fileNum, curPos
        END IF
    NEXT y

    CLOSE #fileNum
END SUB
