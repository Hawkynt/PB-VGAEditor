' BMP File Format Module
' Common Interface: FileBmp_Read, FileBmp_Write
' Namespace: FileBmp (pseudo-namespace via function prefixes)


TYPE BMPHeader
    bfType      AS STRING * 2
    bfSize      AS DWORD
    bfReserved1 AS WORD
    bfReserved2 AS WORD
    bfOffBits   AS DWORD
END TYPE

TYPE BMPInfoHeader
    biSize          AS DWORD
    biWidth         AS DWORD
    biHeight        AS DWORD
    biPlanes        AS WORD
    biBitCount      AS WORD
    biCompression   AS DWORD
    biSizeImage     AS DWORD
    biXPelsPerMeter AS DWORD
    biYPelsPerMeter AS DWORD
    biClrUsed       AS DWORD
    biClrImportant  AS DWORD
END TYPE

'******************************************************************************
'* SUB: FileBmp_Write
'* Purpose: Writes the canvas to a 16-color .BMP file.
'*          Trims transparent pixels from the edges.
'* Parameters:
'*   fullPath (BYVAL STRING): The full path for the new file.
'*   spr (BYREF Sprite): The sprite metadata (for bounding box).
'*   canvas() (BYREF INTEGER): The sprite data array to save.
'******************************************************************************
SUB FileBmp_Write (fullPath AS STRING, errorMessage AS STRING)
    ' Check if there is anything to save
    IF currentSprite.boundingBoxX2 = -1 THEN EXIT SUB
    errorMessage = ""

    DIM spriteWidth AS DWORD
    DIM spriteHeight AS DWORD
    spriteWidth = currentSprite.boundingBoxX2 - currentSprite.boundingBoxX1 + 1
    spriteHeight = currentSprite.boundingBoxY2 - currentSprite.boundingBoxY1 + 1

    DIM rowBytes AS DWORD
    rowBytes = spriteWidth + 1
    SHIFT RIGHT rowBytes, 1
    
    DIM rowPadding AS DWORD
    rowPadding = (4 - (rowBytes AND 3)) AND 3

    DIM imageSize AS DWORD
    imageSize = (rowBytes + rowPadding) * spriteHeight
    
    %fileHeaderSize = 14
    %infoHeaderSize = 40
    %paletteEntries = 16
    %paletteSize = %paletteEntries * 4 'BGRA

    DIM pixelDataOffset AS DWORD
    pixelDataOffset = %fileHeaderSize + %infoHeaderSize + %paletteSize
    DIM fileSize AS DWORD
    fileSize = pixelDataOffset + imageSize

    DIM fileNum AS INTEGER
    fileNum = FREEFILE
    OPEN fullPath FOR BINARY AS #fileNum

      DIM bmpH AS BMPHeader
      bmpH.bfType = "BM"
      bmpH.bfSize = fileSize
      bmpH.bfReserved1 = currentSprite.boundingBoxX1  ' Store original X offset
      bmpH.bfReserved2 = currentSprite.boundingBoxY1  ' Store original Y offset
      bmpH.bfOffBits = pixelDataOffset
      PUT #fileNum, , bmpH
    
      DIM bmpIH AS BMPInfoHeader
      bmpIH.biSize = %infoHeaderSize
      bmpIH.biWidth = spriteWidth
      bmpIH.biHeight = spriteHeight
      bmpIH.biPlanes = 1
      bmpIH.biBitCount = 4
      bmpIH.biCompression = 0
      
      %dpi72 = 2835
      
      bmpIH.biSizeImage = imageSize
      bmpIH.biXPelsPerMeter = %dpi72
      bmpIH.biYPelsPerMeter = %dpi72
      bmpIH.biClrUsed = %paletteEntries
      bmpIH.biClrImportant = %paletteEntries
      PUT #fileNum, , bmpIH
      
      DIM byteVal AS BYTE
      DIM vgaPalette(0 TO 15) AS DWORD
      vgaPalette(0) = &H000000
      vgaPalette(1) = &H0000AA
      vgaPalette(2) = &H00AA00
      vgaPalette(3) = &H00AAAA
      vgaPalette(4) = &HAA0000
      vgaPalette(5) = &HAA00AA
      vgaPalette(6) = &HAA5500
      vgaPalette(7) = &HAAAAAA
      vgaPalette(8) = &H555555
      vgaPalette(9) = &H5555FF
      vgaPalette(10) = &H55FF55
      vgaPalette(11) = &H55FFFF
      vgaPalette(12) = &HFF5555
      vgaPalette(13) = &HFF55FF
      vgaPalette(14) = &HFFFF55
      vgaPalette(15) = &HFFFFFF
      FOR byteVal = 0 TO 15
          PUT #fileNum, , vgaPalette(byteVal)
      NEXT
      
      DIM x AS INTEGER
      DIM y AS INTEGER
      
      FOR y = currentSprite.boundingBoxY2 TO currentSprite.boundingBoxY1 STEP -1
        FOR x = currentSprite.boundingBoxX1 TO currentSprite.boundingBoxX2 STEP 2
          byteVal = currentCanvas(x, y)
          SHIFT LEFT byteVal, 4
          byteVal = byteVal OR currentCanvas(x + 1, y)
          PUT #fileNum, , byteVal
        NEXT
        
        ' Handle odd width: last pixel in high nibble, low nibble 0
        IF x < currentSprite.boundingBoxX2 THEN
          byteVal = currentCanvas(currentSprite.boundingBoxX2, y)
          SHIFT LEFT byteVal, 4
          PUT #fileNum, , byteVal
        END IF
        
        ' Padding: write zero bytes
        byteVal = 0
        FOR x = 0 TO rowPadding - 1
          PUT #fileNum, , byteVal
        NEXT
    NEXT

  CLOSE #fileNum
END SUB

'******************************************************************************
'* SUB: FileBmp_Read
'* Purpose: Reads a 16-color .BMP file into the canvas.
'* Parameters:
'*   fullPath (BYVAL STRING): The full path to the .BMP file.
'*   spr (BYREF Sprite): The sprite metadata.
'*   canvas() (BYREF INTEGER): The sprite data array to fill.
'******************************************************************************
SUB FileBmp_Read (fullPath AS STRING, errorMessage AS STRING)
    DIM bmpH AS BMPHeader
    DIM bmpIH AS BMPInfoHeader
    DIM fileNum AS INTEGER
    DIM spriteWidth AS DWORD
    DIM spriteHeight AS DWORD
    errorMessage = ""

    fileNum = FREEFILE
    ON ERROR RESUME NEXT
    OPEN fullPath FOR BINARY AS #fileNum
    IF ERR <> 0 THEN
        errorMessage = "Cannot open file: " + fullPath
        ERRCLEAR : ON ERROR GOTO 0
        EXIT SUB
    END IF
    ON ERROR GOTO 0

    ' --- Headers ---
    GET #fileNum, , bmpH
    GET #fileNum, , bmpIH

    ' --- Validate ---
    IF bmpH.bfType <> "BM" THEN
        errorMessage = "Not a BMP."
        CLOSE #fileNum : EXIT SUB
    END IF
    IF bmpIH.biBitCount <> 4 THEN
        errorMessage = "Only 4bpp (16-color) BMP supported."
        CLOSE #fileNum : EXIT SUB
    END IF
    IF bmpIH.biCompression <> 0 THEN
        errorMessage = "Compressed BMP not supported."
        CLOSE #fileNum : EXIT SUB
    END IF

    spriteWidth = bmpIH.biWidth
    spriteHeight = bmpIH.biHeight
    
    IF spriteWidth <= 0 OR spriteHeight <= 0 THEN
        errorMessage = "Invalid BMP dimensions."
        CLOSE #fileNum : EXIT SUB
    END IF

    ' Calculate row padding (same as write function)
    DIM rowBytes AS DWORD
    rowBytes = spriteWidth + 1
    SHIFT RIGHT rowBytes, 1
    
    DIM rowPadding AS DWORD  
    rowPadding = (4 - (rowBytes AND 3)) AND 3

    ' Update sprite bounding box to match BMP dimensions at 0,0 position
    currentSprite.boundingBoxX1 = 0
    currentSprite.boundingBoxY1 = 0  
    currentSprite.boundingBoxX2 = spriteWidth - 1
    currentSprite.boundingBoxY2 = spriteHeight - 1

    ' Seek to pixel data
    SEEK fileNum, bmpH.bfOffBits

    ' Read pixel data (bottom-up, matching write order)
    DIM byteVal AS BYTE
    DIM x AS INTEGER
    DIM y AS INTEGER
    
    FOR y = spriteHeight - 1 TO 0 STEP -1
        FOR x = 0 TO spriteWidth - 1 STEP 2
            GET #fileNum, , byteVal
            currentCanvas(x + 1, y) = byteVal AND &H0F
            SHIFT RIGHT byteVal, 4
            currentCanvas(x, y) = byteVal
        NEXT
        
        ' Handle odd width
        IF x < spriteWidth THEN
            GET #fileNum, , byteVal
            SHIFT RIGHT byteVal, 4
            currentCanvas(spriteWidth, y) = byteVal
        END IF
        
        ' Skip row padding
        FOR x = 0 TO rowPadding - 1
            GET #fileNum, , byteVal
        NEXT
    NEXT

    CLOSE #fileNum
END SUB
