' ICO File Format Module
' Common Interface: FileIco_Read, FileIco_Write
' Namespace: FileIco (pseudo-namespace via function prefixes)

TYPE Sprite
    spriteWidth AS INTEGER
    spriteHeight AS INTEGER
    boundingBoxX1 AS INTEGER
    boundingBoxY1 AS INTEGER
    boundingBoxX2 AS INTEGER
    boundingBoxY2 AS INTEGER
END TYPE

TYPE IconDir
    idReserved AS WORD
    idType     AS WORD  
    idCount    AS WORD
END TYPE

TYPE IconDirEntry
    bWidth      AS BYTE
    bHeight     AS BYTE
    bColorCount AS BYTE
    bReserved   AS BYTE
    wPlanes     AS WORD
    wBitCount   AS WORD
    dwBytesInRes AS DWORD
    dwImageOffset AS DWORD
END TYPE

TYPE IconBitmapInfoHeader
    biSize          AS DWORD
    biWidth         AS DWORD
    biHeight        AS DWORD
    biPlanes        AS WORD
    biBitCount      AS WORD
    biCompression   AS DWORD
    biSizeImage     AS DWORD
    biXPelsPerMeter AS DWORD
    biYPelsPerMeter AS DWORD
    biClrUsed       AS DWORD
    biClrImportant  AS DWORD
END TYPE

'******************************************************************************
'* SUB: FileIco_Write
'* Purpose: Writes the canvas to a 16-color .ICO file.
'*          Trims transparent pixels from the edges and creates proper mask.
'* Parameters:
'*   fullPath (BYVAL STRING): The full path for the new file.
'*   spr (BYREF Sprite): The sprite metadata (for bounding box).
'*   canvas() (BYREF INTEGER): The sprite data array to save.
'******************************************************************************
SUB FileIco_Write (fullPath AS STRING, errorMessage AS STRING)
    DIM iconDir AS IconDir
    DIM iconEntry AS IconDirEntry
    DIM bmpInfo AS IconBitmapInfoHeader
    DIM fileNum AS INTEGER
    DIM x AS INTEGER, y AS INTEGER
    DIM spriteWidth AS DWORD, spriteHeight AS DWORD
    DIM imageRowSize AS DWORD, maskRowSize AS DWORD
    DIM imageDataSize AS DWORD, maskDataSize AS DWORD
    DIM totalImageSize AS DWORD
    DIM vgaPalette(0 TO 15) AS DWORD
    DIM pixelByte AS BYTE
    DIM maskByte AS BYTE
    DIM bitPos AS INTEGER
    DIM paddingBytes AS INTEGER
    errorMessage = ""

    ' Check if there is anything to save
    IF currentSprite.boundingBoxX2 = -1 THEN EXIT SUB

    spriteWidth = currentSprite.boundingBoxX2 - currentSprite.boundingBoxX1 + 1
    spriteHeight = currentSprite.boundingBoxY2 - currentSprite.boundingBoxY1 + 1

    ' ICO image data rows padded to 4-byte boundary
    ' 4bpp image: 2 pixels per byte, so we need ceil(width/2) bytes
    DIM bytesPerRow AS DWORD
    bytesPerRow = (spriteWidth + 1) \ 2  ' ceiling division 
    imageRowSize = ((bytesPerRow + 3) \ 4) * 4  ' pad to 4-byte boundary
    imageDataSize = imageRowSize * spriteHeight

    ' 1bpp mask: 8 pixels per byte, padded to 4-byte boundary
    DIM maskBytesPerRow AS DWORD  
    maskBytesPerRow = (spriteWidth + 7) \ 8  ' ceiling division
    maskRowSize = ((maskBytesPerRow + 3) \ 4) * 4  ' pad to 4-byte boundary
    maskDataSize = maskRowSize * spriteHeight

    totalImageSize = 40 + (16 * 4) + imageDataSize + maskDataSize

    ' --- Fill Icon Directory ---
    iconDir.idReserved = 0
    iconDir.idType = 1
    iconDir.idCount = 1

    ' --- Fill Icon Directory Entry ---
    iconEntry.bWidth = spriteWidth AND &HFF
    iconEntry.bHeight = spriteHeight AND &HFF
    iconEntry.bColorCount = 16
    iconEntry.bReserved = 0
    iconEntry.wPlanes = 1
    iconEntry.wBitCount = 4
    iconEntry.dwBytesInRes = totalImageSize
    iconEntry.dwImageOffset = 22   ' 6 + 16

    ' --- Fill Bitmap Info Header (double height for image + mask) ---
    bmpInfo.biSize = 40
    bmpInfo.biWidth = spriteWidth
    bmpInfo.biHeight = spriteHeight * 2
    bmpInfo.biPlanes = 1
    bmpInfo.biBitCount = 4
    bmpInfo.biCompression = 0
    bmpInfo.biSizeImage = imageDataSize + maskDataSize
    bmpInfo.biXPelsPerMeter = 0
    bmpInfo.biYPelsPerMeter = 0
    bmpInfo.biClrUsed = 16
    bmpInfo.biClrImportant = 16

    fileNum = FREEFILE
    OPEN fullPath FOR BINARY AS #fileNum

    ' --- Write Icon Directory ---
    PUT #fileNum, , iconDir
    
    ' --- Write Icon Directory Entry ---
    PUT #fileNum, , iconEntry

    ' --- Write Bitmap Info Header ---
    PUT #fileNum, , bmpInfo

    ' --- Write Palette (BGR format) ---
    vgaPalette(0) = &H000000: vgaPalette(1) = &H0000AA: vgaPalette(2) = &H00AA00: vgaPalette(3) = &H00AAAA
    vgaPalette(4) = &HAA0000: vgaPalette(5) = &HAA00AA: vgaPalette(6) = &HAA5500: vgaPalette(7) = &HAAAAAA
    vgaPalette(8) = &H555555: vgaPalette(9) = &H5555FF: vgaPalette(10) = &H55FF55: vgaPalette(11) = &H55FFFF
    vgaPalette(12) = &HFF5555: vgaPalette(13) = &HFF55FF: vgaPalette(14) = &HFFFF55: vgaPalette(15) = &HFFFFFF
    FOR x = 0 TO 15
        PUT #fileNum, , vgaPalette(x)
    NEXT x

    ' --- Write Image Data (4bpp, upside-down) ---
    FOR y = currentSprite.boundingBoxY2 TO currentSprite.boundingBoxY1 STEP -1
        FOR x = currentSprite.boundingBoxX1 TO currentSprite.boundingBoxX2 STEP 2
            pixelByte = currentCanvas(x, y)
            SHIFT LEFT pixelByte, 4
            IF x + 1 <= currentSprite.boundingBoxX2 THEN
                pixelByte = pixelByte OR currentCanvas(x + 1, y)
            END IF
            PUT #fileNum, , pixelByte
        NEXT x
        ' Pad row to 4-byte boundary
        paddingBytes = imageRowSize - bytesPerRow
        DIM padByte AS BYTE
        padByte = 0
        FOR x = 1 TO paddingBytes
            PUT #fileNum, , padByte
        NEXT x
    NEXT y

    ' --- Write Mask Data (1bpp, upside-down) ---
    FOR y = currentSprite.boundingBoxY2 TO currentSprite.boundingBoxY1 STEP -1
        FOR x = currentSprite.boundingBoxX1 TO currentSprite.boundingBoxX2 STEP 8
            maskByte = 0
            FOR bitPos = 0 TO 7
                IF (x + bitPos) <= currentSprite.boundingBoxX2 THEN
                    ' Transparent pixels (0) get mask bit = 1, opaque pixels get mask bit = 0
                    IF currentCanvas(x + bitPos, y) = 0 THEN
                        ' Set bit using lookup (MSB first): bit 0=128, 1=64, 2=32, 3=16, 4=8, 5=4, 6=2, 7=1
                        SELECT CASE bitPos
                        CASE 0: maskByte = maskByte OR 128
                        CASE 1: maskByte = maskByte OR 64
                        CASE 2: maskByte = maskByte OR 32
                        CASE 3: maskByte = maskByte OR 16
                        CASE 4: maskByte = maskByte OR 8
                        CASE 5: maskByte = maskByte OR 4
                        CASE 6: maskByte = maskByte OR 2
                        CASE 7: maskByte = maskByte OR 1
                        END SELECT
                    END IF
                END IF
            NEXT bitPos
            PUT #fileNum, , maskByte
        NEXT x
        ' Pad mask row to 4-byte boundary
        DIM maskPaddingNeeded AS INTEGER
        maskPaddingNeeded = maskRowSize - maskBytesPerRow
        DIM padMaskByte AS BYTE
        padMaskByte = 0
        FOR x = 1 TO maskPaddingNeeded
            PUT #fileNum, , padMaskByte
        NEXT x
    NEXT y

    CLOSE #fileNum
END SUB

'******************************************************************************
'* SUB: FileIco_Read
'* Purpose: Reads a 16-color .ICO file into the canvas.
'* Parameters:
'*   fullPath (BYVAL STRING): The full path to the .ICO file.
'*   spr (BYREF Sprite): The sprite metadata.
'*   canvas() (BYREF INTEGER): The sprite data array to fill.
'******************************************************************************
SUB FileIco_Read (fullPath AS STRING, errorMessage AS STRING)
    DIM iconDir AS IconDir
    DIM iconEntry AS IconDirEntry
    DIM bmpInfo AS IconBitmapInfoHeader
    DIM x AS INTEGER, y AS INTEGER
    DIM spriteWidth AS DWORD, spriteHeight AS DWORD
    DIM imageRowSize AS DWORD, maskRowSize AS DWORD
    DIM pixelByte AS BYTE
    DIM maskByte AS BYTE, bitPos AS INTEGER
    DIM p1 AS INTEGER, p2 AS INTEGER
    errorMessage = ""

    DIM fileNum AS INTEGER : fileNum = FREEFILE
    ON ERROR RESUME NEXT
    OPEN fullPath FOR BINARY AS #fileNum
    IF ERR <> 0 THEN
        errorMessage = "Cannot open file: " + fullPath
        ERRCLEAR : ON ERROR GOTO 0
        EXIT SUB
    END IF
    ON ERROR GOTO 0

    ' --- Read Icon Directory ---
    GET #fileNum, , iconDir
    
    ' Early validation
    IF iconDir.idReserved <> 0 OR iconDir.idType <> 1 OR iconDir.idCount < 1 THEN
        errorMessage = "Not a valid ICO file (header check failed)."
        CLOSE #fileNum : EXIT SUB
    END IF

    ' --- Read first Icon Directory Entry ---
    GET #fileNum, , iconEntry
    
    spriteWidth = iconEntry.bWidth
    spriteHeight = iconEntry.bHeight
    IF spriteWidth = 0 THEN spriteWidth = 256
    IF spriteHeight = 0 THEN spriteHeight = 256

    ' Validate reasonable dimensions
    IF spriteWidth > 1024 OR spriteHeight > 1024 THEN
        errorMessage = "ICO dimensions too large (max 1024x1024)."
        CLOSE #fileNum : EXIT SUB
    END IF

    IF iconEntry.wBitCount <> 4 THEN
        errorMessage = "Only 4bpp (16-color) ICO supported."
        CLOSE #fileNum : EXIT SUB
    END IF

    ' Validate image offset
    IF iconEntry.dwImageOffset < 22 OR iconEntry.dwImageOffset > LOF(fileNum) THEN
        errorMessage = "Invalid ICO image offset."
        CLOSE #fileNum : EXIT SUB
    END IF

    ' --- Read Bitmap Info Header ---
    SEEK fileNum, iconEntry.dwImageOffset + 1
    GET #fileNum, , bmpInfo
    
    ' --- Seek to image data (skip palette) ---
    ' dwImageOffset points to BMP header, add header(40) + palette(64) to get to image data
    DIM imageDataPos AS LONG
    imageDataPos = iconEntry.dwImageOffset + 40 + (16 * 4)
    SEEK fileNum, imageDataPos

    DIM readBytesPerRow AS DWORD
    readBytesPerRow = (spriteWidth + 1) \ 2  ' ceiling division 
    imageRowSize = ((readBytesPerRow + 3) \ 4) * 4  ' pad to 4-byte boundary
    
    DIM readMaskBytesPerRow AS DWORD  
    readMaskBytesPerRow = (spriteWidth + 7) \ 8  ' ceiling division
    maskRowSize = ((readMaskBytesPerRow + 3) \ 4) * 4  ' pad to 4-byte boundary
 
    ' --- Read Image Data (4bpp, upside-down) - using BMP reader logic ---
    FOR y = spriteHeight - 1 TO 0 STEP -1
        FOR x = 0 TO spriteWidth - 1 STEP 2
            GET #fileNum, , pixelByte
            ' Use exact BMP reader bit ordering (proven to work)
            currentCanvas(x + 1, y) = pixelByte AND &H0F      ' Low nibble to x+1
            SHIFT RIGHT pixelByte, 4
            currentCanvas(x, y) = pixelByte                    ' High nibble to x
        NEXT
        
        ' Handle odd width (copied from BMP reader)
        IF x < spriteWidth THEN
            GET #fileNum, , pixelByte
            SHIFT RIGHT pixelByte, 4
            currentCanvas(spriteWidth, y) = pixelByte
        END IF
        
        ' Skip row padding
        DIM skipBytes AS INTEGER
        skipBytes = imageRowSize - readBytesPerRow
        FOR x = 1 TO skipBytes
            GET #fileNum, , pixelByte  ' dummy read to skip padding
        NEXT x
    NEXT y

    ' --- Read and Apply Mask Data (1bpp, upside-down) ---
    FOR y = spriteHeight - 1 TO 0 STEP -1
        FOR x = 0 TO spriteWidth - 1 STEP 8
            GET #fileNum, , maskByte
            FOR bitPos = 0 TO 7
                IF (x + bitPos) < spriteWidth THEN
                    ' If mask bit is 1, pixel is transparent  
                    ' Check bit using simple shift: bit 0=128, 1=64, 2=32, etc.
                    IF bitPos = 0 AND (maskByte AND 128) <> 0 THEN currentCanvas(x + bitPos, y) = 0
                    IF bitPos = 1 AND (maskByte AND 64) <> 0 THEN currentCanvas(x + bitPos, y) = 0
                    IF bitPos = 2 AND (maskByte AND 32) <> 0 THEN currentCanvas(x + bitPos, y) = 0
                    IF bitPos = 3 AND (maskByte AND 16) <> 0 THEN currentCanvas(x + bitPos, y) = 0
                    IF bitPos = 4 AND (maskByte AND 8) <> 0 THEN currentCanvas(x + bitPos, y) = 0
                    IF bitPos = 5 AND (maskByte AND 4) <> 0 THEN currentCanvas(x + bitPos, y) = 0
                    IF bitPos = 6 AND (maskByte AND 2) <> 0 THEN currentCanvas(x + bitPos, y) = 0
                    IF bitPos = 7 AND (maskByte AND 1) <> 0 THEN currentCanvas(x + bitPos, y) = 0
                END IF
            NEXT bitPos
        NEXT x
        
        ' Skip mask row padding
        skipBytes = maskRowSize - readMaskBytesPerRow
        FOR x = 1 TO skipBytes
            GET #fileNum, , maskByte  ' dummy read to skip padding
        NEXT x
    NEXT y

    CLOSE #fileNum
    
    ' Load sprite at 0,0 position
    currentSprite.boundingBoxX1 = 0
    currentSprite.boundingBoxY1 = 0
    currentSprite.boundingBoxX2 = spriteWidth - 1
    currentSprite.boundingBoxY2 = spriteHeight - 1
   
END SUB