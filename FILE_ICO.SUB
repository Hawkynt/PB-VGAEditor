' .ICO File Format Module


TYPE ICONDIR
    idReserved  AS INTEGER
    idType      AS INTEGER
    idCount     AS INTEGER
END TYPE

TYPE ICONDIRENTRY
    bWidth          AS STRING * 1
    bHeight         AS STRING * 1
    bColorCount     AS STRING * 1
    bReserved       AS STRING * 1
    wPlanes         AS INTEGER
    wBitCount       AS INTEGER
    dwBytesInRes    AS LONG
    dwImageOffset   AS LONG
END TYPE

TYPE BITMAPINFOHEADER
    biSize          AS LONG
    biWidth         AS LONG
    biHeight        AS LONG
    biPlanes        AS INTEGER
    biBitCount      AS INTEGER
    biCompression   AS LONG
    biSizeImage     AS LONG
    biXPelsPerMeter AS LONG
    biYPelsPerMeter AS LONG
    biClrUsed       AS LONG
    biClrImportant  AS LONG
END TYPE

'******************************************************************************
'* SUB: WriteICOFile
'* Purpose: Writes the canvas to a 16-color .ICO file.
'*          Trims transparent pixels from the edges.
'* Parameters:
'*   fullPath (BYVAL STRING): The full path for the new file.
'*   spr (BYREF Sprite): The sprite metadata (for bounding box).
'*   canvas() (BYREF INTEGER): The sprite data array to save.
'******************************************************************************
SUB WriteICOFile (BYVAL fullPath AS STRING, spr AS Sprite, canvas() AS INTEGER, errorMessage AS STRING)
    DIM idir AS ICONDIR
    DIM ide AS ICONDIRENTRY
    DIM bmih AS BITMAPINFOHEADER
    DIM fileNum AS INTEGER
    DIM x AS INTEGER
    DIM y AS INTEGER
    DIM spriteWidth AS INTEGER
    DIM spriteHeight AS INTEGER
    DIM xorMaskRowSize AS INTEGER
    DIM andMaskRowSize AS INTEGER
    DIM xorMaskSize AS LONG
    DIM andMaskSize AS LONG
    DIM vgaPalette(0 TO 15) AS LONG
    DIM byteVal AS STRING * 1
    DIM p1 AS INTEGER
    DIM p2 AS INTEGER
    DIM bitIndex AS INTEGER
    DIM currentBit AS INTEGER
    DIM paddingBytes AS STRING
    errorMessage = ""

    ' Check if there is anything to save
    IF spr.boundingBoxX2 = -1 THEN EXIT SUB

    spriteWidth = spr.boundingBoxX2 - spr.boundingBoxX1 + 1
    spriteHeight = spr.boundingBoxY2 - spr.boundingBoxY1 + 1

    ' Row sizes must be padded to a multiple of 4 bytes
    xorMaskRowSize = INT((spriteWidth * 4 + 31) / 32) * 4
    andMaskRowSize = INT((spriteWidth + 31) / 32) * 4
    xorMaskSize = xorMaskRowSize * spriteHeight
    andMaskSize = andMaskRowSize * spriteHeight

    ' --- Fill Icon Directory ---
    idir.idReserved = 0
    idir.idType = 1 ' Icon
    idir.idCount = 1 ' One image

    ' --- Fill Icon Directory Entry ---
    ide.bWidth = CHR$(spriteWidth)
    ide.bHeight = CHR$(spriteHeight)
    ide.bColorCount = CHR$(16)
    ide.bReserved = CHR$(0)
    ide.wPlanes = 1
    ide.wBitCount = 4
    ide.dwBytesInRes = 40 + (16 * 4) + xorMaskSize + andMaskSize
    ide.dwImageOffset = 6 + 16 ' Offset to BITMAPINFOHEADER

    ' --- Fill DIB Header ---
    bmih.biSize = 40
    bmih.biWidth = spriteWidth
    bmih.biHeight = spriteHeight * 2 ' Height is doubled for XOR and AND masks
    bmih.biPlanes = 1
    bmih.biBitCount = 4
    bmih.biCompression = 0
    bmih.biSizeImage = xorMaskSize + andMaskSize
    bmih.biXPelsPerMeter = 0
    bmih.biYPelsPerMeter = 0
    bmih.biClrUsed = 16
    bmih.biClrImportant = 16

    fileNum = FREEFILE
    OPEN fullPath FOR BINARY AS #fileNum

    ' --- Write Headers ---
    PUT #fileNum, , idir
    PUT #fileNum, , ide
    PUT #fileNum, , bmih

    ' --- Write Palette (BGR format) ---
    vgaPalette(0) = &H000000: vgaPalette(1) = &HAA0000: vgaPalette(2) = &H00AA00: vgaPalette(3) = &HAAAA00
    vgaPalette(4) = &H0000AA: vgaPalette(5) = &HAA00AA: vgaPalette(6) = &H0055AA: vgaPalette(7) = &HAAAAAA
    vgaPalette(8) = &H555555: vgaPalette(9) = &HFF5555: vgaPalette(10) = &H55FF55: vgaPalette(11) = &HFFFF55
    vgaPalette(12) = &H5555FF: vgaPalette(13) = &HFF55FF: vgaPalette(14) = &H55FFFF: vgaPalette(15) = &HFFFFFF
    FOR x = 0 TO 15
        PUT #fileNum, , vgaPalette(x)
    NEXT x

    ' --- Write XOR (Color) Mask (upside-down) ---
    FOR y = spr.boundingBoxY2 TO spr.boundingBoxY1 STEP -1
        FOR x = spr.boundingBoxX1 TO spr.boundingBoxX2 STEP 2
            p1 = canvas(x, y)
            IF x + 1 > spr.boundingBoxX2 THEN p2 = 0 ELSE p2 = canvas(x + 1, y)
            byteVal = CHR$((p1 * 16) + p2)
            PUT #fileNum, , byteVal
        NEXT x
        IF xorMaskRowSize - (spriteWidth / 2) > 0 THEN
            paddingBytes = STRING$(xorMaskRowSize - (spriteWidth / 2), 0)
            PUT #fileNum, , paddingBytes
        END IF
    NEXT y

    ' --- Write AND (Opacity) Mask (upside-down) ---
    FOR y = spr.boundingBoxY2 TO spr.boundingBoxY1 STEP -1
        FOR x = spr.boundingBoxX1 TO spr.boundingBoxX2 STEP 8
            byteVal = CHR$(0)
            FOR bitIndex = 0 TO 7
                currentBit = 0
                IF x + bitIndex <= spr.boundingBoxX2 THEN
                    IF canvas(x + bitIndex, y) = 0 THEN currentBit = 1
                END IF
                byteVal = CHR$(ASC(byteVal) OR (currentBit * (2 ^ (7 - bitIndex))))
            NEXT bitIndex
            PUT #fileNum, , byteVal
        NEXT x
        IF andMaskRowSize - INT((spriteWidth + 7) / 8) > 0 THEN
            paddingBytes = STRING$(andMaskRowSize - INT((spriteWidth + 7) / 8), 0)
            PUT #fileNum, , paddingBytes
        END IF
    NEXT y

    CLOSE #fileNum
END SUB

'******************************************************************************
'* SUB: ReadICOFile
'* Purpose: Reads a 16-color .ICO file into the canvas.
'* Parameters:
'*   fullPath (BYVAL STRING): The full path to the .ICO file.
'*   spr (BYREF Sprite): The sprite metadata.
'*   canvas() (BYREF INTEGER): The sprite data array to fill.
'******************************************************************************
SUB ReadICOFile (BYVAL fullPath AS STRING, spr AS Sprite, canvas() AS INTEGER, errorMessage AS STRING)
    DIM idir AS ICONDIR
    DIM ide(255) AS ICONDIRENTRY
    DIM bmih AS BITMAPINFOHEADER
    DIM fileNum AS INTEGER
    DIM i AS INTEGER
    DIM bestEntry AS INTEGER
    DIM bestRes AS INTEGER
    DIM x AS INTEGER
    DIM y AS INTEGER
    DIM spriteWidth AS INTEGER
    DIM spriteHeight AS INTEGER
    DIM startX AS INTEGER
    DIM startY AS INTEGER
    DIM xorMaskRowSize AS INTEGER
    DIM andMaskRowSize AS INTEGER
    DIM byteVal AS STRING * 1
    DIM p1 AS INTEGER
    DIM p2 AS INTEGER
    DIM andByte AS STRING * 1
    DIM bitIndex AS INTEGER
    errorMessage = ""

    fileNum = FREEFILE
    OPEN fullPath FOR BINARY AS #fileNum

    ' --- Read Icon Directory Header ---
    GET #fileNum, , idir

    IF idir.idType <> 1 THEN
        errorMessage = "Not a valid ICO file."
        CLOSE #fileNum
        EXIT SUB
    END IF

    ' --- Read All Icon Directory Entries ---
    FOR i = 0 TO idir.idCount - 1
        GET #fileNum, , ide(i)
    NEXT i

    ' --- Find the Best-Fitting 16-Color Image ---
    bestEntry = -1
    bestRes = 0
    FOR i = 0 TO idir.idCount - 1
        spriteWidth = ASC(ide(i).bWidth)
        spriteHeight = ASC(ide(i).bHeight)
        IF ide(i).wBitCount = 4 AND spriteWidth <= spr.spriteWidth AND spriteHeight <= spr.spriteHeight THEN
            IF spriteWidth * spriteHeight > bestRes THEN
                bestRes = spriteWidth * spriteHeight
                bestEntry = i
            END IF
        END IF
    NEXT i

    IF bestEntry = -1 THEN
        errorMessage = "No suitable 16-color icon found in file."
        CLOSE #fileNum
        EXIT SUB
    END IF

    ' --- Seek to the Best Image's Data and Read its DIB Header ---
    SEEK fileNum, ide(bestEntry).dwImageOffset + 1
    GET #fileNum, , bmih

    spriteWidth = ASC(ide(bestEntry).bWidth)
    spriteHeight = ASC(ide(bestEntry).bHeight)
    xorMaskRowSize = INT((spriteWidth * 4 + 31) / 32) * 4
    andMaskRowSize = INT((spriteWidth + 31) / 32) * 4

    ' Center the image on the canvas
    startX = (spr.spriteWidth - spriteWidth) / 2
    startY = (spr.spriteHeight - spriteHeight) / 2

    ' --- Seek to XOR Mask (Color Data) ---
    SEEK fileNum, ide(bestEntry).dwImageOffset + bmih.biSize + (16 * 4) + 1

    ' --- Read XOR (Color) and AND (Opacity) Masks ---
    FOR y = spriteHeight - 1 TO 0 STEP -1
        FOR x = 0 TO spriteWidth - 1 STEP 2
            byteVal = INPUT$(1, #fileNum)
            p1 = ASC(byteVal) \ 16
            p2 = ASC(byteVal) AND 15
            IF (startX + x) <= spr.spriteWidth AND (startY + y) <= spr.spriteHeight THEN canvas(startX + x, startY + y) = p1
            IF (startX + x + 1) <= spr.spriteWidth AND (startY + y) <= spr.spriteHeight THEN canvas(startX + x + 1, startY + y) = p2
        NEXT x
        IF xorMaskRowSize - (spriteWidth / 2) > 0 THEN SEEK fileNum, LOF(fileNum) - (LOF(fileNum) - (SEEK(fileNum) + (xorMaskRowSize - (spriteWidth / 2))))
    NEXT y

    FOR y = spriteHeight - 1 TO 0 STEP -1
        FOR x = 0 TO spriteWidth - 1 STEP 8
            andByte = INPUT$(1, #fileNum)
            FOR bitIndex = 0 TO 7
                IF (ASC(andByte) AND (2 ^ (7 - bitIndex))) <> 0 THEN
                    IF (startX + x + bitIndex) <= spr.spriteWidth AND (startY + y) <= spr.spriteHeight THEN
                        canvas(startX + x + bitIndex, startY + y) = 0
                    END IF
                END IF
            NEXT bitIndex
        NEXT x
        IF andMaskRowSize - INT((spriteWidth + 7) / 8) > 0 THEN SEEK fileNum, LOF(fileNum) - (LOF(fileNum) - (SEEK(fileNum) + (andMaskRowSize - INT((spriteWidth + 7) / 8))))
    NEXT y

    CLOSE #fileNum
END SUB
